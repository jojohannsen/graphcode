<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization System</title>
    
    <!-- Prism CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 2fr 1fr 3fr;
            height: 100vh;
            gap: 1px;
            background-color: #2a2a2a;
        }
        
        .column {
            background-color: #1a1a1a;
            overflow-y: auto;
            padding: 20px;
        }
        
        /* First column - Graph display */
        .graph-column {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            position: relative;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        .graph-header {
            background-color: #2d3142;
            color: #e8e9eb;
            padding: 8px 20px;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 1px solid #3a3d4e;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        
        .graph-header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .graph-path {
            color: #888;
            font-weight: normal;
        }
        
        .graph-filename {
            font-weight: bold;
            color: #e8e9eb;
        }
        
        .download-icon {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .download-icon:hover {
            background-color: #2a2a2a;
            color: #4caf50;
        }
        
        .graph-content-wrapper {
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
        }
        
        .file-list {
            display: block;
        }
        
        .graph-display {
            display: none;
        }
        
        .file-item {
            padding: 8px 12px;
            margin: 4px 0 4px 20px;
            background-color: #2a2a2a;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
            border-left: 3px solid #404040;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
        }
        
        .file-item.has-folder {
            color: #9cdcfe;
        }
        
        .file-item:hover {
            background-color: #353535;
            color: #ffffff;
            border-left-color: #569cd6;
        }
        
        .file-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #666;
            margin-left: 8px;
            flex-shrink: 0;
        }
        
        .file-status-indicator.has-artifacts {
            background-color: #4caf50;
        }
        
        .graph-header-buttons {
            position: absolute;
            top: 10px;
            right: 15px;
            display: flex;
            gap: 8px;
        }
        
        .header-button {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .header-button:hover {
            background-color: #2a2a2a;
            color: #ccc;
        }
        
        .action-button {
            background-color: #333333;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            cursor: pointer;
            border-radius: 8px;
        }
        
        .header-button.edit-button:hover {
            color: #ccc;
        }
        
        .graph-line {
            margin: 2px 0;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .graph-line:hover {
            background-color: #2a2a2a;
        }
        
        .graph-comment {
            color: #6a9955;
            font-style: italic;
        }
        
        .graph-state {
            color: #569cd6;
            font-weight: bold;
        }
        
        .graph-node {
            color: #9cdcfe;
        }
        
        .graph-arrow {
            color: #d4d4d4;
        }
        
        .graph-end {
            color: #ce9178;
            font-weight: bold;
        }
        
        /* Second column - Navigation */
        .nav-column {
            border-left: 1px solid #2a2a2a;
            border-right: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
            padding: 0;
        }
        
        .nav-link {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            margin: 4px 0;
            text-decoration: none;
            color: #b0b0b0;
            background-color: #252525;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 14px;
            cursor: pointer;
        }
        
        .nav-link-checkmark {
            color: #4caf50;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .nav-link-checkmark.visible {
            opacity: 1;
        }
        
        .nav-link:hover:not(.disabled) {
            background-color: #353535;
            color: #ffffff;
        }
        
        .nav-link.active {
            background-color: #2a4e7d;
            color: #ffffff;
        }
        
        .nav-link.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: #1d1d1d;
            color: #606060;
        }
        
        .nav-link.disabled:hover {
            transform: none;
        }
        
        .nav-link.generating {
            pointer-events: none;
            opacity: 0.7;
            background-color: #3a3d4e !important;
            cursor: wait;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 320px;
            max-width: 90vw;
            background-color: #e8f4f8;
            color: #2c3e50;
            text-align: left;
            border-radius: 8px;
            padding: 12px 16px;
            position: fixed;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            font-size: 13px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            border: 2px solid #b8dae6;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            line-height: 1.4;
            word-wrap: break-word;
            pointer-events: none;
        }
        
        .tooltip .tooltip-text.show {
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Third column - Content display */
        .content-column {
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .content-header {
            background-color: #2d3142;
            color: #e8e9eb;
            padding: 8px 20px;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 1px solid #3a3d4e;
            min-height: 36px;
            display: flex;
            align-items: center;
            flex-shrink: 0;
            margin: 0;
            justify-content: space-between;
        }
        
        .content-header.welcome-style {
            background-color: #1a1a1a;
            color: #ffffff;
            font-size: 20px;
            font-weight: 600;
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .content-body-wrapper {
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
        }
        
        .delete-button {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            transition: all 0.2s;
            margin-left: auto;
            display: none;
        }
        
        .delete-button:hover {
            background-color: #2a2a2a;
            color: #ff6b6b;
        }
        
        .delete-button.visible {
            display: block;
        }
        
        .content-body {
            font-size: 14px;
            line-height: 1.8;
        }
        
        /* Markdown styling */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            margin: 20px 0 10px 0;
            color: #ffffff;
        }
        
        .markdown-content h1 {
            font-size: 28px;
            border-bottom: 2px solid #3a3a3a;
            padding-bottom: 8px;
        }
        
        .markdown-content h2 {
            font-size: 22px;
        }
        
        .markdown-content p {
            margin: 12px 0;
        }
        
        .markdown-content code {
            background-color: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }
        
        .markdown-content pre {
            background-color: #2a2a2a;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 16px 0;
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 12px 0;
            padding-left: 24px;
        }
        
        .markdown-content li {
            margin: 6px 0;
        }
        
        /* Code block styling */
        pre[class*="language-"] {
            background-color: #2a2a2a;
            border-radius: 6px;
            padding: 16px;
            margin: 0;
        }
        
        /* Loading indicator */
        .loading {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            font-size: 16px;
            color: #f1c40f;
            font-style: italic;
            padding-left: 20px;
        }
        
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 16px;
            color: #ff6b6b;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .modal {
            background-color: #2d3142;
            border-radius: 12px;
            padding: 0;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.7) translateY(-20px);
            transition: all 0.3s ease;
            border: 1px solid #3a3d4e;
        }
        
        .modal-overlay.show .modal {
            transform: scale(1) translateY(0);
        }
        
        .modal-header {
            padding: 24px 24px 16px 24px;
            border-bottom: 1px solid #3a3d4e;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .modal-icon {
            font-size: 20px;
            color: #ff6b6b;
        }
        
        .modal-body {
            padding: 20px 24px;
        }
        
        .modal-message {
            color: #e0e0e0;
            font-size: 14px;
            line-height: 1.5;
            margin: 0;
        }
        
        .modal-filename {
            color: #9cdcfe;
            font-family: 'Consolas', 'Monaco', monospace;
            font-weight: 500;
        }
        
        .modal-footer {
            padding: 16px 24px 24px 24px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
        }
        
        .modal-button-cancel {
            background-color: #3a3d4e;
            color: #e0e0e0;
        }
        
        .modal-button-cancel:hover {
            background-color: #4a4d5e;
        }
        
        .modal-button-delete {
            background-color: #ff6b6b;
            color: #ffffff;
        }
        
        .modal-button-delete:hover {
            background-color: #ff5252;
        }
        
        .modal-button:focus {
            outline: 2px solid #569cd6;
            outline-offset: 2px;
        }
        
        /* Edit mode styles */
        .editor-container {
            display: none;
            position: relative;
            width: 100%;
            margin-bottom: 12px;
        }
        
        .editor-container.show {
            display: block;
        }
        
        .graph-editor {
            width: 100%;
            height: 400px;
            background-color: transparent;
            color: transparent;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            outline: none;
            position: relative;
            z-index: 2;
            caret-color: #e0e0e0;
        }
        
        .graph-editor:focus {
            border-color: #569cd6;
        }
        
        .editor-highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #1e1e1e;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            pointer-events: none;
            z-index: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
        }
        
        .edit-controls {
            display: none;
            gap: 12px;
            justify-content: flex-end;
            padding: 8px 0;
        }
        
        .edit-controls.show {
            display: flex;
        }
        
        .edit-button-control {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .save-button-control {
            background-color: #4caf50;
            color: #ffffff;
        }
        
        .save-button-control:hover {
            background-color: #66bb6a;
        }
        
        .cancel-button-control {
            background-color: #3a3d4e;
            color: #e0e0e0;
        }
        
        .cancel-button-control:hover {
            background-color: #4a4d5e;
        }
        
        #graphContent.edit-mode {
            display: none;
        }
        
        /* Create new graph button styles */
        .create-graph-button {
            background: none;
            border: none;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .create-graph-button:hover {
            background-color: #2a2a2a;
            color: #4caf50;
        }
        
        /* Create graph modal styles */
        .graph-name-input {
            width: 100%;
            padding: 12px;
            margin: 12px 0 8px 0;
            background-color: #1a1a1a;
            border: 2px solid #3a3d4e;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            outline: none;
            transition: border-color 0.2s ease;
        }
        
        .graph-name-input:focus {
            border-color: #569cd6;
        }
        
        .graph-name-input::placeholder {
            color: #666;
        }
        
        .input-help {
            font-size: 12px;
            color: #888;
            margin: 0 0 8px 0;
        }
        
        /* Add minimal CSS for folder-item and folder-header */
        /* Place after .file-item styles */
        .folder-item {
            margin-bottom: 4px;
        }
        .folder-header {
            font-weight: bold;
            color: #b0b0b0;
            padding: 6px 8px;
            border-radius: 4px;
            background-color: #232323;
            transition: background-color 0.2s;
        }
        .folder-header:hover {
            background-color: #353535;
            color: #ffffff;
        }
        .folder-arrow {
            font-size: 12px;
            display: inline-block;
            width: 16px;
            text-align: center;
        }
        .folder-content {
            margin-left: 12px;
            border-left: 1px solid #222;
            padding-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- First column: Graph/File List -->
        <div class="column graph-column" id="graphColumn">
            <div class="graph-header" id="graphsListHeader">
                <div class="graph-header-title">
                    <span>Graphs</span>
                </div>
                <button class="create-graph-button" id="createGraphButton" title="Create a new graph file">
                    <span>➕</span>
                    <span>+ Create New Graph</span>
                </button>
            </div>
            <div class="graph-header" id="graphHeader" style="display: none;">
                <div class="graph-header-title">
                    <span id="selectedFileName"></span>
                </div>
            </div>
            <div class="graph-content-wrapper">
                <div class="file-list" id="fileList">
                    <div class="loading">Loading files...</div>
                </div>
                <div class="graph-display" id="graphDisplay">
                    <div class="graph-header-buttons">
                        <button class="header-button edit-button" id="editGraph" title="Edit graph content">✎</button>
                        <button class="header-button" id="closeGraph" title="Close and return to file list">✕</button>
                    </div>
                    <div id="graphContent"></div>
                    <div class="editor-container" id="editorContainer">
                        <div class="editor-highlight" id="editorHighlight"></div>
                        <textarea class="graph-editor" id="graphEditor" placeholder="Enter graph content here..."></textarea>
                    </div>
                    <div class="edit-controls" id="editControls">
                        <button class="edit-button-control cancel-button-control" id="cancelEdit">Cancel</button>
                        <button class="edit-button-control save-button-control" id="saveGraph">Save</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Second column: Navigation -->
        <div class="column nav-column">
            <div class="graph-header">
                <div class="graph-header-title">
                    <span>Graph Artifacts</span>
                    <button class="download-icon" id="downloadZip" title="Download ZIP">⬇</button>
                </div>
            </div>
            <nav style="padding: 20px;">
                <a href="#" class="nav-link active" data-file="readme">
                    <span>README</span>
                    <span class="nav-link-checkmark" id="checkmark-readme">📖</span>
                </a>
                <a href="#" title="Generate state-spec.md" class="nav-link disabled tooltip" data-file="state_spec" id="state-spec-button">
                    <span>state spec</span>
                    <span class="nav-link-checkmark" id="checkmark-state_spec">✓</span>
                </a>
                <a href="#" title="Generate state_code.py" class="nav-link disabled" data-file="state_code">
                    <span>state code</span>
                    <span class="nav-link-checkmark" id="checkmark-state_code">✓</span>
                </a>
                <a href="#" title="Generate node-spec.md" class="nav-link disabled tooltip" data-file="node_spec" id="node-spec-button">
                    <span>node spec</span>
                    <span class="nav-link-checkmark" id="checkmark-node_spec">✓</span>
                </a>
                <a href="#" title="Generate node_code.py" class="nav-link disabled" data-file="node_code">
                    <span>node code</span>
                    <span class="nav-link-checkmark" id="checkmark-node_code">✓</span>
                </a>
                <a href="#" title="Generate graph_code.py" class="nav-link disabled" data-file="graph_code">
                    <span>graph code</span>
                    <span class="nav-link-checkmark" id="checkmark-graph_code">✓</span>
                </a>
                <a href="#" title="Generate main.py" class="nav-link disabled" data-file="main">
                    <span>main</span>
                    <span class="nav-link-checkmark" id="checkmark-main">✓</span>
                </a>
            </nav>
        </div>
        
        <!-- Third column: Content Display -->
        <div class="column content-column">
            <div class="graph-header" id="contentHeader">
                <div class="graph-header-title">
                    <span>Langgraph Code Generator</span>
                </div>
                <button class="delete-button" id="deleteButton" title="Delete this file">🗑️</button>
            </div>
            <div class="content-body-wrapper">
                <div class="content-body" id="contentBody">
                    <p>Start by selecting a graph from the navigation menu to view its contents.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Confirm Delete Modal -->
    <div class="modal-overlay" id="confirmModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">
                    <span class="modal-icon">⚠️</span>
                    Confirm Delete
                </h3>
            </div>
            <div class="modal-body">
                <p class="modal-message">
                    Are you sure you want to delete <span class="modal-filename" id="modalFilename"></span>?
                    <br><br>
                    This action cannot be undone.
                </p>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-button-cancel" id="modalCancel">Cancel</button>
                <button class="modal-button modal-button-delete" id="modalConfirm">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Confirm Save Modal -->
    <div class="modal-overlay" id="confirmSaveModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">
                    <span class="modal-icon">💾</span>
                    Confirm Save
                </h3>
            </div>
            <div class="modal-body">
                <p class="modal-message">
                    Are you sure you want to save changes to <span class="modal-filename" id="saveModalFilename"></span>?
                    <br><br>
                    This will overwrite the original file.
                </p>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-button-cancel" id="saveModalCancel">Cancel</button>
                <button class="modal-button modal-button-delete" id="saveModalConfirm">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Create New Graph Modal -->
    <div class="modal-overlay" id="createGraphModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">
                    <span class="modal-icon">📊</span>
                    Create New Graph
                </h3>
            </div>
            <div class="modal-body">
                <p class="modal-message">
                    Enter a name for your new graph:
                </p>
                <input type="text" id="graphNameInput" class="graph-name-input" placeholder="Graph name (e.g., my_workflow)" autocomplete="off">
                <p class="input-help">Name can only contain letters, numbers, underscores, and hyphens</p>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-button-cancel" id="createGraphCancel">Cancel</button>
                <button class="modal-button modal-button-delete" id="createGraphConfirm">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    
    <!-- Marked JS for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    
    <script>
        // Global variable for generation interval
        let generationInterval = null;
        
        // Parse and display graph with color coding
        function parseGraph(graphContent) {
            const lines = graphContent.split('\n');
            const graphContent_div = document.getElementById('graphContent');
            graphContent_div.innerHTML = '';
            
            lines.forEach(line => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'graph-line';
                
                if (line.trim().startsWith('#')) {
                    // Comment
                    lineDiv.innerHTML = `<span class="graph-comment">${line}</span>`;
                } else if (line.includes('->')) {
                    // Connection
                    const parts = line.split('->');
                    const source = parts[0].trim();
                    const target = parts[1].trim();
                    
                    let sourceClass = 'graph-node';
                    let targetClass = 'graph-node';
                    
                    if (source === 'State') sourceClass = 'graph-state';
                    if (target === 'END') targetClass = 'graph-end';
                    
                    lineDiv.innerHTML = `<span class="${sourceClass}">${source}</span> <span class="graph-arrow">-></span> <span class="${targetClass}">${target}</span>`;
                } else if (line.trim()) {
                    // Other content
                    lineDiv.textContent = line;
                }
                
                if (line.trim()) {
                    graphContent_div.appendChild(lineDiv);
                }
            });
        }
        
        // Apply syntax highlighting to editor
        function highlightEditorContent(content) {
            const lines = content.split('\n');
            let highlighted = '';
            
            lines.forEach((line, index) => {
                if (index > 0) highlighted += '\n';
                
                if (line.trim().startsWith('#')) {
                    // Comment
                    highlighted += `<span class="graph-comment">${escapeHtml(line)}</span>`;
                } else if (line.includes('->')) {
                    // Connection
                    const parts = line.split('->');
                    const source = parts[0].trim();
                    const target = parts[1].trim();
                    const beforeSource = line.substring(0, line.indexOf(source));
                    const afterTarget = line.substring(line.indexOf(target) + target.length);
                    
                    let sourceClass = 'graph-node';
                    let targetClass = 'graph-node';
                    
                    if (source === 'State') sourceClass = 'graph-state';
                    if (target === 'END') targetClass = 'graph-end';
                    
                    highlighted += `${escapeHtml(beforeSource)}<span class="${sourceClass}">${escapeHtml(source)}</span> <span class="graph-arrow">-></span> <span class="${targetClass}">${escapeHtml(target)}</span>${escapeHtml(afterTarget)}`;
                } else {
                    // Other content
                    highlighted += escapeHtml(line);
                }
            });
            
            return highlighted;
        }
        
        // Escape HTML characters
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Update editor highlighting
        function updateEditorHighlight() {
            const editor = document.getElementById('graphEditor');
            const highlight = document.getElementById('editorHighlight');
            const content = editor.value;
            
            highlight.innerHTML = highlightEditorContent(content);
            
            // Sync scroll position
            highlight.scrollTop = editor.scrollTop;
            highlight.scrollLeft = editor.scrollLeft;
        }
        
        // Load and display txt files (now supports nested folders)
        async function loadTxtFiles() {
            try {
                const response = await fetch('/api/txt-files');
                const data = await response.json();
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                function createFolderNode(folder, parentPath = '') {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder-item';
                    folderDiv.style.marginLeft = parentPath ? '16px' : '0';

                    // Folder header
                    const header = document.createElement('div');
                    header.className = 'folder-header';
                    header.style.cursor = 'pointer';
                    header.style.display = 'flex';
                    header.style.alignItems = 'center';
                    header.style.gap = '6px';
                    header.innerHTML = `<span class="folder-arrow">▶</span> <span>${folder.name}</span>`;
                    folderDiv.appendChild(header);

                    // Folder content (hidden by default)
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'folder-content';
                    contentDiv.style.display = 'none';
                    folderDiv.appendChild(contentDiv);

                    // Toggle expand/collapse
                    header.addEventListener('click', () => {
                        const isOpen = contentDiv.style.display === 'block';
                        contentDiv.style.display = isOpen ? 'none' : 'block';
                        header.querySelector('.folder-arrow').textContent = isOpen ? '▶' : '▼';
                    });

                    // Add subfolders
                    (folder.folders || []).forEach(subfolder => {
                        contentDiv.appendChild(createFolderNode(subfolder, parentPath + folder.name + '/'));
                    });
                    // Add files
                    (folder.files || []).forEach(async filename => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        
                        // Remove .txt extension for display
                        const displayName = filename.replace('.txt', '');
                        
                        // Create file content structure
                        const fileContent = document.createElement('span');
                        fileContent.textContent = displayName;
                        
                        const statusIndicator = document.createElement('div');
                        statusIndicator.className = 'file-status-indicator';
                        
                        fileItem.appendChild(fileContent);
                        fileItem.appendChild(statusIndicator);
                        
                        // Check if artifacts exist for this file
                        const relPath = parentPath + folder.name + '/' + filename;
                        const cleanPath = relPath.startsWith('graphs/') ? relPath.slice(7) : relPath;
                        const graphName = cleanPath.replace('.txt', '');
                        
                        // Check for any generated artifacts
                        try {
                            const response = await fetch(`/api/check-file/${graphName}/state-spec.md`);
                            if (response.ok) {
                                statusIndicator.classList.add('has-artifacts');
                                fileItem.classList.add('has-folder');
                            }
                        } catch (error) {
                            // Silent fail for status check
                        }
                        
                        fileItem.addEventListener('click', () => {
                            loadGraphFromFile(cleanPath);
                        });
                        contentDiv.appendChild(fileItem);
                    });
                    return folderDiv;
                }

                // If no .txt files at all
                if ((data.files.length === 0) && (!data.folders || data.folders.length === 0)) {
                    fileList.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No .txt files found in the graphs directory</div>';
                    return;
                }

                // Render top-level folders and files
                (data.folders || []).forEach(folder => {
                    fileList.appendChild(createFolderNode(folder));
                });
                (data.files || []).forEach(async filename => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    
                    // Remove .txt extension for display
                    const displayName = filename.replace('.txt', '');
                    
                    // Create file content structure
                    const fileContent = document.createElement('span');
                    fileContent.textContent = displayName;
                    
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'file-status-indicator';
                    
                    fileItem.appendChild(fileContent);
                    fileItem.appendChild(statusIndicator);
                    
                    // Check if artifacts exist for this file
                    const graphName = filename.replace('.txt', '');
                    
                    // Check for any generated artifacts
                    try {
                        const response = await fetch(`/api/check-file/${graphName}/state-spec.md`);
                        if (response.ok) {
                            statusIndicator.classList.add('has-artifacts');
                            fileItem.classList.add('has-folder');
                        }
                    } catch (error) {
                        // Silent fail for status check
                    }
                    
                    fileItem.addEventListener('click', () => loadGraphFromFile(filename));
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error loading txt files:', error);
                document.getElementById('fileList').innerHTML = '<div class="error">Error loading files</div>';
            }
        }
        
        // Track current loaded file and displayed artifact
        let currentLoadedFile = null;
        let currentDisplayedArtifact = null;
        let isEditMode = false;
        let originalGraphContent = '';
        
        // Check which files exist for a given graph name
        async function checkExistingFiles(graphName) {
            const fileChecks = {
                state_spec: `${graphName}/state-spec.md`,
                state_code: `${graphName}/state_code.py`, 
                node_spec: `${graphName}/node-spec.md`,
                node_code: `${graphName}/node_code.py`,
                graph_code: `${graphName}/graph_code.py`,
                main: `${graphName}/main.py`
            };
            
            const existingFiles = {};
            
            for (const [key, filePath] of Object.entries(fileChecks)) {
                try {
                    const response = await fetch(`/api/check-file/${filePath}`);
                    existingFiles[key] = response.ok;
                } catch (error) {
                    existingFiles[key] = false;
                }
            }
            
            return existingFiles;
        }
        
        // Update checkmark visibility based on file existence
        function updateCheckmarks(existingFiles) {
            const checkmarks = {
                state_spec: document.getElementById('checkmark-state_spec'),
                state_code: document.getElementById('checkmark-state_code'),
                node_spec: document.getElementById('checkmark-node_spec'),
                node_code: document.getElementById('checkmark-node_code'),
                graph_code: document.getElementById('checkmark-graph_code'),
                main: document.getElementById('checkmark-main')
            };
            const buttonIds = {
                state_spec: 'state-spec-button',
                state_code: null, // no id, use querySelector
                node_spec: 'node-spec-button',
                node_code: null,
                graph_code: null,
                main: null
            };
            const fileNames = {
                state_spec: 'state-spec.md',
                state_code: 'state_code.py',
                node_spec: 'node-spec.md',
                node_code: 'node_code.py',
                graph_code: 'graph_code.py',
                main: 'main.py'
            };
            // Update checkmark visibility for each artifact
            Object.keys(checkmarks).forEach(key => {
                const checkmark = checkmarks[key];
                if (existingFiles[key]) {
                    checkmark.classList.add('visible');
                } else {
                    checkmark.classList.remove('visible');
                }
                // Dynamically update the button title
                let button = null;
                if (buttonIds[key]) {
                    button = document.getElementById(buttonIds[key]);
                } else {
                    // fallback: select by data-file
                    button = document.querySelector(`[data-file="${key}"]`);
                }
                if (button && checkmark) {
                    if (checkmark.classList.contains('visible')) {
                        button.title = `View ${fileNames[key]}`;
                    } else {
                        button.title = `Generate ${fileNames[key]}`;
                    }
                }
            });
        }
        
        // Update button states based on file dependencies
        function updateButtonStates(existingFiles, activeButtonKey = null) {
            const buttons = {
                readme: document.querySelector('[data-file="readme"]'),
                state_spec: document.querySelector('[data-file="state_spec"]'),
                state_code: document.querySelector('[data-file="state_code"]'),
                node_spec: document.querySelector('[data-file="node_spec"]'),
                node_code: document.querySelector('[data-file="node_code"]'),
                graph_code: document.querySelector('[data-file="graph_code"]'),
                main: document.querySelector('[data-file="main"]')
            };
            
            // Reset all buttons to disabled
            Object.values(buttons).forEach(button => {
                button.classList.add('disabled');
                button.classList.remove('active');
            });
            
            // README is always enabled and active by default
            buttons.readme.classList.remove('disabled');
            
            // State spec is always enabled when a file is loaded
            buttons.state_spec.classList.remove('disabled');
            
            // Enable buttons based on file dependencies before setting active state
            // State code enabled if state spec exists
            if (existingFiles.state_spec) {
                buttons.state_code.classList.remove('disabled');
            }
            
            // Node spec enabled if state code button is enabled and state_code.py exists
            if (!buttons.state_code.classList.contains('disabled') && existingFiles.state_code) {
                buttons.node_spec.classList.remove('disabled');
            }
            
            // Node code enabled if node spec button is enabled and node-spec.md exists
            if (!buttons.node_spec.classList.contains('disabled') && existingFiles.node_spec) {
                buttons.node_code.classList.remove('disabled');
            }
            
            // Graph code enabled if node code button is enabled and node_code.py exists
            if (!buttons.node_code.classList.contains('disabled') && existingFiles.node_code) {
                buttons.graph_code.classList.remove('disabled');
            }
            
            // Main enabled if graph code button is enabled and graph_code.py exists
            if (!buttons.graph_code.classList.contains('disabled') && existingFiles.graph_code) {
                buttons.main.classList.remove('disabled');
            }

            // Determine which button should be active
            if (activeButtonKey && buttons[activeButtonKey] && !buttons[activeButtonKey].classList.contains('disabled')) {
                // Use the specified active button - don't auto-load content as it should already be displayed
                buttons[activeButtonKey].classList.add('active');
            } else if (existingFiles.state_spec) {
                buttons.state_spec.classList.add('active');
                // Load the existing state spec content only if no specific button was requested
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                displayExistingFile(`${fileNameWithoutExt}/state-spec.md`, true);
            } else {
                buttons.readme.classList.add('active');
            }
            
            // Update checkmarks
            updateCheckmarks(existingFiles);
        }
        
        // Update tooltip with correct path
        function updateTooltips(graphName) {
            const tooltipText = `Generate <b>state-spec.md</b>`;
            
            // Update the custom tooltip
            const tooltip = document.getElementById('state-spec-tooltip');
            if (tooltip) {
                tooltip.innerHTML = tooltipText;
            }
        }
        
        // Smart tooltip positioning
        function positionTooltip(button, tooltip) {
            console.log('positionTooltip called for button:', button.id);
            const buttonRect = button.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            
            // Use a fixed width for calculation
            const tooltipWidth = 320;
            const tooltipHeight = 60; // Approximate height
            
            // Position tooltip slightly above and aligned to the left of the button
            let left = buttonRect.left;
            let top = buttonRect.top - tooltipHeight - 10;
            
            console.log('Calculated initial position (top, left):', top, left);
            
            // Adjust if tooltip goes off the right edge
            if (left + tooltipWidth > viewportWidth - 10) {
                left = viewportWidth - tooltipWidth - 10;
                console.log('Adjusted left for right edge:', left);
            }
            
            // Adjust if tooltip goes off the left edge
            if (left < 10) {
                left = 10;
                console.log('Adjusted left for left edge:', left);
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            console.log('Final tooltip style set:', { left: tooltip.style.left, top: tooltip.style.top });
        }
        
        // Load graph from specific file
        async function loadGraphFromFile(filename) {
            try {
                const response = await fetch(`/api/graph/${filename}`);
                const data = await response.json();
                
                if (data.error) {
                    alert(`Error loading file: ${data.error}`);
                    return;
                }
                
                // Store current file and content
                currentLoadedFile = filename;
                originalGraphContent = data.content;
                
                // Store README content if available
                window.currentReadmeContent = data.readme || null;
                
                // Switch to graph display
                document.getElementById('fileList').style.display = 'none';
                document.getElementById('graphDisplay').style.display = 'block';
                document.getElementById('graphsListHeader').style.display = 'none';
                
                // Show header with filename
                const fileNameWithoutExt = filename.replace('.txt', '');
                const selectedFileNameElement = document.getElementById('selectedFileName');
                
                // Split the path and format with different styles
                if (fileNameWithoutExt.includes('/')) {
                    const pathParts = fileNameWithoutExt.split('/');
                    const fileName = pathParts.pop();
                    const pathPrefix = pathParts.join('/') + '/';
                    selectedFileNameElement.innerHTML = `<span class="graph-path">${pathPrefix}</span><span class="graph-filename">${fileName}</span>`;
                } else {
                    selectedFileNameElement.innerHTML = `<span class="graph-filename">${fileNameWithoutExt}</span>`;
                }
                
                document.getElementById('graphHeader').style.display = 'flex';
                
                // Check existing files and update button states
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles);
                
                // Update tooltips with correct paths
                updateTooltips(fileNameWithoutExt);
                
                parseGraph(data.content);
                
                // Load and display the graph overview in the third column
                await loadGraphOverview(filename);
                
            } catch (error) {
                console.error('Error loading graph:', error);
                alert('Error loading graph file');
            }
        }
        
        // Show file list and hide graph
        function showFileList() {
            document.getElementById('fileList').style.display = 'block';
            document.getElementById('graphDisplay').style.display = 'none';
            document.getElementById('graphHeader').style.display = 'none';
            document.getElementById('graphsListHeader').style.display = 'flex';
            
            // Clear current file
            currentLoadedFile = null;
            
            // Disable all navigation links and hide checkmarks
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.add('disabled');
                link.classList.remove('active');
            });
            
            // Hide all checkmarks
            document.querySelectorAll('.nav-link-checkmark').forEach(checkmark => {
                checkmark.classList.remove('visible');
            });
            
            // Reset content area with welcome style
            const contentHeader = document.getElementById('contentHeader');
            contentHeader.innerHTML = '<div class="graph-header-title"><span>Welcome</span></div><button class="delete-button" id="deleteButton" title="Delete this file">🗑️</button>';
            contentHeader.className = 'graph-header';
            document.getElementById('contentBody').innerHTML = '<p>Select a file from the navigation menu to view its contents.</p>';
            hideDeleteButton();
        }
        
        // Show create graph modal
        function showCreateGraphModal() {
            const modal = document.getElementById('createGraphModal');
            const input = document.getElementById('graphNameInput');
            
            input.value = '';
            modal.classList.add('show');
            
            // Focus the input after modal animation
            setTimeout(() => input.focus(), 300);
        }
        
        // Hide create graph modal
        function hideCreateGraphModal() {
            const modal = document.getElementById('createGraphModal');
            modal.classList.remove('show');
        }
        
        // Create new file
        async function createNewFile() {
            showCreateGraphModal();
        }
        
        // Actually create the file with the given name
        async function createGraphFile(filename) {
            // Validate filename
            if (!/^[a-zA-Z0-9_-]+$/.test(filename)) {
                alert('Filename can only contain letters, numbers, underscores, and hyphens');
                return false;
            }
            
            const fullFilename = filename + '.txt';
            
            // Check if file already exists
            try {
                const response = await fetch('/api/txt-files');
                const data = await response.json();
                if (data.files.includes(fullFilename)) {
                    alert(`File ${fullFilename} already exists. Please choose a different name.`);
                    return false;
                }
            } catch (error) {
                console.error('Error checking existing files:', error);
            }
            
            // Load template content
            let defaultContent;
            try {
                const templateResponse = await fetch('/api/get-file/templates/new_graph.txt');
                const templateData = await templateResponse.json();
                if (templateData.content) {
                    defaultContent = templateData.content;
                } else {
                    throw new Error('Template not found');
                }
            } catch (error) {
                console.error('Error loading template:', error);
                // Fallback content if template fails to load
                defaultContent = `# ${filename} Graph Definition
# Define your graph transitions below
# Format: source -> target
# Example:
# State -> start_node
# start_node -> process_node
# process_node -> END
`;
            }
            
            try {
                const response = await fetch(`/api/save-file/${fullFilename}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: defaultContent })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    alert(`Error creating file: ${data.error}`);
                    return false;
                }
                
                // Also create the YAML config file
                try {
                    // Load default.yaml content
                    const yamlResponse = await fetch('/api/get-file/default.yaml');
                    const yamlData = await yamlResponse.json();
                    
                    if (yamlData.content) {
                        const yamlFilename = filename + '.yaml';
                        const yamlSaveResponse = await fetch(`/api/save-file/${yamlFilename}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ content: yamlData.content })
                        });
                        
                        const yamlSaveData = await yamlSaveResponse.json();
                        if (yamlSaveData.error) {
                            console.warn(`Warning: Could not create ${yamlFilename}:`, yamlSaveData.error);
                        } else {
                            console.log(`Created ${yamlFilename} successfully`);
                        }
                    }
                } catch (error) {
                    console.warn('Warning: Could not create YAML config file:', error);
                }
                
                // File created successfully, now load it in edit mode
                currentLoadedFile = fullFilename;
                originalGraphContent = defaultContent;
                
                // Switch to graph display
                document.getElementById('fileList').style.display = 'none';
                document.getElementById('graphDisplay').style.display = 'block';
                document.getElementById('graphsListHeader').style.display = 'none';
                
                // Show header with filename
                const selectedFileNameElement = document.getElementById('selectedFileName');
                
                // Split the path and format with different styles
                if (filename.includes('/')) {
                    const pathParts = filename.split('/');
                    const fileNamePart = pathParts.pop();
                    const pathPrefix = pathParts.join('/') + '/';
                    selectedFileNameElement.innerHTML = `<span class="graph-path">${pathPrefix}</span><span class="graph-filename">${fileNamePart}</span>`;
                } else {
                    selectedFileNameElement.innerHTML = `<span class="graph-filename">${filename}</span>`;
                }
                
                document.getElementById('graphHeader').style.display = 'flex';
                
                // Enter edit mode immediately
                parseGraph(defaultContent);
                enterEditMode();
                
                return true;
                
            } catch (error) {
                console.error('Error creating file:', error);
                alert('Error creating file');
                return false;
            }
        }
        
        // Initialize close button
        function initializeCloseButton() {
            document.getElementById('closeGraph').addEventListener('click', showFileList);
        }
        
        // Enter edit mode
        function enterEditMode() {
            if (isEditMode) return;
            
            isEditMode = true;
            
            // Show editor with current content
            const editor = document.getElementById('graphEditor');
            const editorContainer = document.getElementById('editorContainer');
            
            editor.value = originalGraphContent;
            editorContainer.classList.add('show');
            
            // Initial highlighting
            updateEditorHighlight();
            
            // Hide graph display and show edit controls
            document.getElementById('graphContent').classList.add('edit-mode');
            document.getElementById('editControls').classList.add('show');
            
            // Hide edit button
            document.getElementById('editGraph').style.display = 'none';
            
            // Disable all navigation buttons
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.add('disabled');
                link.style.pointerEvents = 'none';
                link.style.opacity = '0.3';
            });
            
            // Add event listeners for real-time highlighting
            editor.addEventListener('input', updateEditorHighlight);
            editor.addEventListener('scroll', updateEditorHighlight);
            
            // Focus the editor
            editor.focus();
        }
        
        // Exit edit mode
        function exitEditMode(saveChanges = false) {
            if (!isEditMode) return;
            
            const editor = document.getElementById('graphEditor');
            const editorContainer = document.getElementById('editorContainer');
            
            if (saveChanges) {
                // Update graph content with edited content
                originalGraphContent = editor.value;
                parseGraph(originalGraphContent);
            }
            
            isEditMode = false;
            
            // Remove event listeners
            editor.removeEventListener('input', updateEditorHighlight);
            editor.removeEventListener('scroll', updateEditorHighlight);
            
            // Hide editor and edit controls
            editorContainer.classList.remove('show');
            document.getElementById('editControls').classList.remove('show');
            
            // Show graph display and edit button
            document.getElementById('graphContent').classList.remove('edit-mode');
            document.getElementById('editGraph').style.display = 'block';
            
            // Re-enable navigation buttons (with proper state checking)
            if (currentLoadedFile) {
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                checkExistingFiles(fileNameWithoutExt).then(existingFiles => {
                    updateButtonStates(existingFiles);
                    // Remove the edit-mode specific styling
                    document.querySelectorAll('.nav-link').forEach(link => {
                        link.style.pointerEvents = '';
                        link.style.opacity = '';
                    });
                });
            }
        }
        
        // Show save confirmation modal
        function showSaveConfirmModal(fileName, onConfirm) {
            const modal = document.getElementById('confirmSaveModal');
            const modalFilename = document.getElementById('saveModalFilename');
            
            modalFilename.textContent = fileName;
            modal.classList.add('show');
            
            // Handle confirm button
            const confirmButton = document.getElementById('saveModalConfirm');
            const cancelButton = document.getElementById('saveModalCancel');
            
            const handleConfirm = () => {
                hideSaveConfirmModal();
                onConfirm();
                confirmButton.removeEventListener('click', handleConfirm);
                cancelButton.removeEventListener('click', handleCancel);
            };
            
            const handleCancel = () => {
                hideSaveConfirmModal();
                confirmButton.removeEventListener('click', handleConfirm);
                cancelButton.removeEventListener('click', handleCancel);
            };
            
            confirmButton.addEventListener('click', handleConfirm);
            cancelButton.addEventListener('click', handleCancel);
            
            // Close on overlay click
            const handleOverlayClick = (e) => {
                if (e.target === modal) {
                    handleCancel();
                    modal.removeEventListener('click', handleOverlayClick);
                }
            };
            modal.addEventListener('click', handleOverlayClick);
            
            // Close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    handleCancel();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Hide save confirmation modal
        function hideSaveConfirmModal() {
            const modal = document.getElementById('confirmSaveModal');
            modal.classList.remove('show');
        }
        
        // Save graph changes
        async function saveGraphChanges() {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            const editor = document.getElementById('graphEditor');
            const newContent = editor.value;
            
            showSaveConfirmModal(currentLoadedFile, async () => {
                try {
                    const response = await fetch(`/api/save-file/${currentLoadedFile}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ content: newContent })
                    });
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        alert(`Error saving file: ${data.error}`);
                        return;
                    }
                    
                    // Exit edit mode and update display
                    exitEditMode(true);
                    
                    // Show success message (optional)
                    console.log('File saved successfully');
                    
                } catch (error) {
                    console.error('Error saving file:', error);
                    alert('Error saving file');
                }
            });
        }
        
        // Start generation process feedback
        function startGeneration(button, message) {
            // Hide any active tooltips
            const tooltip = document.getElementById('state-spec-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }

            // Set button to generating state
            if (button) {
                button.classList.add('generating');
            }

            // Display animated loading message
            const contentBody = document.getElementById('contentBody');
            contentBody.innerHTML = `<div class="loading">${message}</div>`;
            const loadingElement = contentBody.querySelector('.loading');

            if (generationInterval) {
                clearInterval(generationInterval);
            }

            let dotCount = 0;
            generationInterval = setInterval(() => {
                dotCount = (dotCount % 333) + 1;
                const dots = '.'.repeat(dotCount);
                if (loadingElement) {
                    loadingElement.textContent = `${message}${dots}`;
                }
            }, 1000);
        }

        // Stop generation process feedback
        function stopGeneration(button) {
            if (generationInterval) {
                clearInterval(generationInterval);
                generationInterval = null;
            }
            if (button) {
                button.classList.remove('generating');
            }
        }
        
        // Generate state spec
        async function generateStateSpec(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating state specification');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/state-spec', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated markdown
                contentBody.innerHTML = `<div class="markdown-content">${marked.parse(data.content)}</div>`;
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/state-spec.md`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep state_spec active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'state_spec');
                
            } catch (error) {
                console.error('Error generating state spec:', error);
                contentBody.innerHTML = '<div class="error">Error generating state specification</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Generate state code
        async function generateStateCode(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating state code');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/state-code', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated Python code with syntax highlighting
                contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                Prism.highlightAll();
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/state_code.py`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep state_code active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'state_code');
                
            } catch (error) {
                console.error('Error generating state code:', error);
                contentBody.innerHTML = '<div class="error">Error generating state code</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Generate node spec
        async function generateNodeSpec(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating node specification');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/node-spec', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated markdown
                contentBody.innerHTML = `<div class="markdown-content">${marked.parse(data.content)}</div>`;
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/node-spec.md`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep node_spec active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'node_spec');
                
            } catch (error) {
                console.error('Error generating node spec:', error);
                contentBody.innerHTML = '<div class="error">Error generating node specification</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Generate node code
        async function generateNodeCode(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating node code');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/node-code', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated Python code with syntax highlighting
                contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                Prism.highlightAll();
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/node_code.py`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep node_code active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'node_code');
                
            } catch (error) {
                console.error('Error generating node code:', error);
                contentBody.innerHTML = '<div class="error">Error generating node code</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Generate graph code
        async function generateGraphCode(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating graph code');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/graph-code', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated Python code with syntax highlighting
                contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                Prism.highlightAll();
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/graph_code.py`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep graph_code active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'graph_code');
                
            } catch (error) {
                console.error('Error generating graph code:', error);
                contentBody.innerHTML = '<div class="error">Error generating graph code</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Generate main code
        async function generateMain(button) {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            startGeneration(button, 'Generating main code');
            const contentBody = document.getElementById('contentBody');
            
            try {
                const response = await fetch('/api/generate/main', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filename: currentLoadedFile })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    return;
                }
                
                // Display the generated Python code with syntax highlighting
                contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                Prism.highlightAll();
                
                // Show delete button and track current artifact
                const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                currentDisplayedArtifact = `${fileNameWithoutExt}/main.py`;
                showDeleteButton();
                
                // Refresh button states after successful generation and keep main active
                const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                updateButtonStates(existingFiles, 'main');
                
            } catch (error) {
                console.error('Error generating main code:', error);
                contentBody.innerHTML = '<div class="error">Error generating main code</div>';
                hideDeleteButton();
            } finally {
                stopGeneration(button);
            }
        }
        
        // Display existing file content
        async function displayExistingFile(filePath, isMarkdown = false) {
            const contentBody = document.getElementById('contentBody');
            contentBody.innerHTML = '<div class="loading">Loading existing file...</div>';
            
            try {
                const response = await fetch(`/api/get-file/${filePath}`);
                const data = await response.json();
                
                if (data.error) {
                    contentBody.innerHTML = `<div class="error">Error: ${data.error}</div>`;
                    hideDeleteButton();
                    return false;
                }
                
                if (isMarkdown) {
                    // Display markdown content
                    contentBody.innerHTML = `<div class="markdown-content">${marked.parse(data.content)}</div>`;
                } else {
                    // Display Python code with syntax highlighting
                    contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                    Prism.highlightAll();
                }
                
                // Show delete button and track current artifact
                currentDisplayedArtifact = filePath;
                showDeleteButton();
                
                return true;
            } catch (error) {
                console.error('Error loading existing file:', error);
                contentBody.innerHTML = '<div class="error">Error loading existing file</div>';
                hideDeleteButton();
                return false;
            }
        }
        
        // Show delete button
        function showDeleteButton() {
            document.getElementById('deleteButton').classList.add('visible');
        }
        
        // Hide delete button
        function hideDeleteButton() {
            document.getElementById('deleteButton').classList.remove('visible');
            currentDisplayedArtifact = null;
        }
        
        // Show confirm modal
        function showConfirmModal(fileName, onConfirm) {
            const modal = document.getElementById('confirmModal');
            const modalFilename = document.getElementById('modalFilename');
            
            modalFilename.textContent = fileName;
            modal.classList.add('show');
            
            // Handle confirm button
            const confirmButton = document.getElementById('modalConfirm');
            const cancelButton = document.getElementById('modalCancel');
            
            const handleConfirm = () => {
                hideConfirmModal();
                onConfirm();
                confirmButton.removeEventListener('click', handleConfirm);
                cancelButton.removeEventListener('click', handleCancel);
            };
            
            const handleCancel = () => {
                hideConfirmModal();
                confirmButton.removeEventListener('click', handleConfirm);
                cancelButton.removeEventListener('click', handleCancel);
            };
            
            confirmButton.addEventListener('click', handleConfirm);
            cancelButton.addEventListener('click', handleCancel);
            
            // Close on overlay click
            const handleOverlayClick = (e) => {
                if (e.target === modal) {
                    handleCancel();
                    modal.removeEventListener('click', handleOverlayClick);
                }
            };
            modal.addEventListener('click', handleOverlayClick);
            
            // Close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    handleCancel();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Hide confirm modal
        function hideConfirmModal() {
            const modal = document.getElementById('confirmModal');
            modal.classList.remove('show');
        }
        
        // Delete current artifact
        async function deleteCurrentArtifact() {
            if (!currentDisplayedArtifact) {
                return;
            }
            
            const fileName = currentDisplayedArtifact.split('/').pop();
            
            showConfirmModal(fileName, async () => {
                try {
                    const response = await fetch(`/api/delete-file/${currentDisplayedArtifact}`, {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        alert(`Error deleting file: ${data.error}`);
                        return;
                    }
                    
                    // Update UI after successful deletion
                    const contentBody = document.getElementById('contentBody');
                    contentBody.innerHTML = `<div class="loading">
                        <p>'${fileName}' has been deleted.</p>
                    </div>`;
                    
                    hideDeleteButton();
                    
                    // Refresh button states
                    if (currentLoadedFile) {
                        const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                        const existingFiles = await checkExistingFiles(fileNameWithoutExt);
                        updateButtonStates(existingFiles);
                    }
                    
                } catch (error) {
                    console.error('Error deleting file:', error);
                    alert('Error deleting file');
                }
            });
        }
        
        // Download zip file with all artifacts
        function downloadZipFile() {
            if (!currentLoadedFile) {
                alert('No file loaded');
                return;
            }
            
            // Create a link element and trigger download
            const downloadUrl = `/api/download-zip/${currentLoadedFile}`;
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = `${currentLoadedFile.replace('.txt', '')}_artifacts.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Load and display graph overview
        async function loadGraphOverview(filename) {
            const contentHeader = document.getElementById('contentHeader');
            const contentBody = document.getElementById('contentBody');
            
            contentHeader.innerHTML = '<div class="graph-header-title"><span>README</span></div>';
            contentHeader.className = 'graph-header';
            
            // Use extracted README content if available, otherwise fall back to overview
            if (window.currentReadmeContent) {
                // Display the extracted README content as markdown
                contentBody.innerHTML = `<div class="markdown-content">${marked.parse(window.currentReadmeContent)}</div>`;
            } else {
                // Fall back to the dynamic overview if no README was extracted
                try {
                    const response = await fetch(`/api/graph-overview/${filename}`);
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error('Error loading graph overview:', data.error);
                        contentBody.innerHTML = '<div class="markdown-content"><h1>README</h1><p>No documentation available for this graph.</p></div>';
                        return;
                    }
                    
                    // Display the overview markdown
                    contentBody.innerHTML = `<div class="markdown-content">${marked.parse(data.content)}</div>`;
                    
                } catch (error) {
                    console.error('Error loading graph overview:', error);
                    contentBody.innerHTML = '<div class="markdown-content"><h1>README</h1><p>Error loading documentation.</p></div>';
                }
            }
            
            // Hide delete button since this is not a deletable artifact
            hideDeleteButton();
            
            // Ensure README button is active
            document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
            const readmeButton = document.querySelector('[data-file="readme"]');
            if (readmeButton) {
                readmeButton.classList.add('active');
            }
        }
        
        // Handle navigation clicks
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Check if link is disabled
                if (link.classList.contains('disabled')) {
                    return;
                }
                
                // Update active state
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                const fileKey = link.dataset.file;
                const fileName = link.querySelector('span').textContent;
                
                // Special handling for README button
                if (fileKey === 'readme') {
                    if (currentLoadedFile) {
                        await loadGraphOverview(currentLoadedFile);
                    } else {
                        // Show generic README content if no file is loaded
                        const contentHeader = document.getElementById('contentHeader');
                        const contentBody = document.getElementById('contentBody');
                        
                        contentHeader.innerHTML = '<div class="graph-header-title"><span>README</span></div>';
                        contentHeader.className = 'graph-header';
                        
                        contentBody.innerHTML = `<div class="markdown-content">
                            <h1>Graph Visualization System</h1>
                            <p>Select a graph file from the left panel to view its overview and generate artifacts.</p>
                            <h2>Getting Started</h2>
                            <ol>
                                <li>Click "Create New Graph" to create a new graph file</li>
                                <li>Or select an existing .txt file from the list</li>
                                <li>Use the navigation buttons to generate different artifacts</li>
                                <li>Download the complete project as a ZIP file</li>
                            </ol>
                        </div>`;
                        
                        hideDeleteButton();
                    }
                    return;
                }
                
                // Update header with file-loaded style
                const contentHeader = document.getElementById('contentHeader');
                contentHeader.innerHTML = `<div class="graph-header-title"><span>${fileName}</span></div><button class="delete-button" id="deleteButton" title="Delete this file">🗑️</button>`;
                contentHeader.className = 'graph-header';
                
                // Special handling for files that can be generated
                if (currentLoadedFile) {
                    const fileNameWithoutExt = currentLoadedFile.replace('.txt', '');
                    
                    // Define file mappings
                    const fileMapping = {
                        'state_spec': { path: `${fileNameWithoutExt}/state-spec.md`, isMarkdown: true, generateFunc: generateStateSpec },
                        'state_code': { path: `${fileNameWithoutExt}/state_code.py`, isMarkdown: false, generateFunc: generateStateCode },
                        'node_spec': { path: `${fileNameWithoutExt}/node-spec.md`, isMarkdown: true, generateFunc: generateNodeSpec },
                        'node_code': { path: `${fileNameWithoutExt}/node_code.py`, isMarkdown: false, generateFunc: generateNodeCode },
                        'graph_code': { path: `${fileNameWithoutExt}/graph_code.py`, isMarkdown: false, generateFunc: generateGraphCode },
                        'main': { path: `${fileNameWithoutExt}/main.py`, isMarkdown: false, generateFunc: generateMain }
                    };
                    
                    if (fileMapping[fileKey]) {
                        const mapping = fileMapping[fileKey];
                        
                        // Try to display existing file first
                        const displayed = await displayExistingFile(mapping.path, mapping.isMarkdown);
                        
                        // If file doesn't exist, generate it
                        if (!displayed) {
                            await mapping.generateFunc(link);
                        }
                        
                        return;
                    }
                }
                
                // Show loading
                document.getElementById('contentBody').innerHTML = '<div class="loading">Loading...</div>';
                
                try {
                    const response = await fetch(`/api/file/${fileKey}`);
                    const data = await response.json();
                    
                    const contentBody = document.getElementById('contentBody');
                    
                    if (fileKey.includes('spec')) {
                        // Render markdown
                        contentBody.innerHTML = `<div class="markdown-content">${marked.parse(data.content)}</div>`;
                    } else {
                        // Render Python code with syntax highlighting
                        contentBody.innerHTML = `<pre><code class="language-python">${data.content}</code></pre>`;
                        Prism.highlightAll();
                    }
                } catch (error) {
                    console.error('Error loading file:', error);
                    document.getElementById('contentBody').innerHTML = '<div class="error">Error loading file</div>';
                }
            });
        });
        
        // Initialize the application
        loadTxtFiles();
        initializeCloseButton();
        
        // Initialize delete button (use event delegation since button gets recreated)
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'deleteButton') {
                deleteCurrentArtifact();
            }
            
            // Handle edit button
            if (e.target && e.target.id === 'editGraph') {
                enterEditMode();
            }
            
            // Handle save button
            if (e.target && e.target.id === 'saveGraph') {
                saveGraphChanges();
            }
            
            // Handle cancel button
            if (e.target && e.target.id === 'cancelEdit') {
                exitEditMode(false);
            }
            
            // Handle download zip button
            if (e.target && e.target.id === 'downloadZip') {
                downloadZipFile();
            }
            
            // Handle create graph button
            if (e.target && e.target.id === 'createGraphButton') {
                createNewFile();
            }
            
            // Handle create graph modal buttons
            if (e.target && e.target.id === 'createGraphCancel') {
                hideCreateGraphModal();
            }
            
            if (e.target && e.target.id === 'createGraphConfirm') {
                const input = document.getElementById('graphNameInput');
                const filename = input.value.trim();
                
                if (!filename) {
                    alert('Please enter a graph name');
                    return;
                }
                
                createGraphFile(filename).then(success => {
                    if (success) {
                        hideCreateGraphModal();
                    }
                });
            }
        });
        
        // Handle Enter key in graph name input
        document.getElementById('graphNameInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const filename = this.value.trim();
                
                if (!filename) {
                    alert('Please enter a graph name');
                    return;
                }
                
                createGraphFile(filename).then(success => {
                    if (success) {
                        hideCreateGraphModal();
                    }
                });
            }
        });
        
        // Handle Escape key to close modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('createGraphModal');
                if (modal.classList.contains('show')) {
                    hideCreateGraphModal();
                }
            }
        });
        
        // Setup tooltip positioning
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded event fired. Setting up tooltip.');
            const stateSpecButton = document.getElementById('state-spec-button');
            const tooltip = document.getElementById('state-spec-tooltip');
            
            if (stateSpecButton && tooltip) {
                console.log('Found state-spec-button and tooltip element. Attaching events.');
                stateSpecButton.addEventListener('mouseenter', function(e) {
                    const checkmark = stateSpecButton.querySelector('#checkmark-state_spec');
                    if (checkmark && !checkmark.classList.contains('visible')) {
                        console.log('Mouse entered state-spec-button.');
                        // Position the tooltip first
                        positionTooltip(stateSpecButton, tooltip);
                        
                        // Then show it
                        console.log('Adding "show" class to tooltip.');
                        tooltip.classList.add('show');
                    }
                });
                
                stateSpecButton.addEventListener('mouseleave', function(e) {
                    console.log('Mouse left state-spec-button.');
                    console.log('Removing "show" class from tooltip.');
                    tooltip.classList.remove('show');
                });
            } else {
                console.error('Could not find state-spec-button or tooltip element.');
            }
        });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const createGraphButton = document.getElementById('createGraphButton');
        if (createGraphButton) {
            createGraphButton.addEventListener('click', createNewFile);
        }
    });
    </script>
</body>
</html>